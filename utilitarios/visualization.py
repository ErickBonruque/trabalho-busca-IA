"""
M칩dulo respons치vel pelas utilidades, visualiza칞칚o e fun칞칫es auxiliares.
Renderiza칞칚o do ambiente, simula칞칚o de movimento e gera칞칚o de ambientes.
"""

import time
import os
import random
from nucleo.graph import Graph, TipoTerreno, gerar_grafo_labirinto_com_biomas


def limpar_console():
    """Limpa o console de forma compat칤vel com Windows e Linux"""
    os.system('cls' if os.name == 'nt' else 'clear')


def renderizar_mapa(grafo, agente=None, caminho=None, destacar_nos=None):
    """
    Renderiza o mapa do grafo em ASCII
    
    Args:
        grafo (Graph): Grafo do ambiente
        agente (Agent): Agente para mostrar posi칞칚o atual (opcional)
        caminho (list): Caminho para destacar (opcional)
        destacar_nos (list): N칩s espec칤ficos para destacar (opcional)
        
    Returns:
        str: Representa칞칚o ASCII do mapa
    """
    if not grafo.nos:
        return "Grafo vazio"
    
    # Cria matriz para renderiza칞칚o
    matriz = []
    for y in range(grafo.altura):
        linha = []
        for x in range(grafo.largura):
            no = grafo.obter_no(x, y)
            if no:
                linha.append(no.obter_simbolo())
            else:
                linha.append('#')  # Parede (n칩 inexistente)
        matriz.append(linha)
    
    # Marca caminho se fornecido
    if caminho:
        for i, no in enumerate(caminho):
            if i == 0:
                matriz[no.y][no.x] = 'S'  # In칤cio
            elif i == len(caminho) - 1:
                matriz[no.y][no.x] = 'G'  # Goal/Objetivo
            else:
                # S칩 marca como caminho se n칚o for recompensa
                if not no.tem_recompensa:
                    matriz[no.y][no.x] = '.'  # Caminho
    
    # Marca posi칞칚o do agente
    if agente:
        matriz[agente.posicao_atual.y][agente.posicao_atual.x] = 'A'
    
    # Destaca n칩s espec칤ficos
    if destacar_nos:
        for no in destacar_nos:
            matriz[no.y][no.x] = '+'  # Destaque especial
    
    # Constr칩i string de sa칤da
    resultado = []
    resultado.append("   " + "".join(f"{i:2}" for i in range(grafo.largura)))
    resultado.append("   " + "--" * grafo.largura)
    
    for y, linha in enumerate(matriz):
        linha_str = f"{y:2}|" + " ".join(f"{celula}" for celula in linha)
        resultado.append(linha_str)
    
    return "\n".join(resultado)


def renderizar_mapa_com_legenda(grafo, agente=None, caminho=None):
    """
    Renderiza mapa com legenda explicativa
    
    Args:
        grafo (Graph): Grafo do ambiente
        agente (Agent): Agente (opcional)
        caminho (list): Caminho (opcional)
        
    Returns:
        str: Mapa com legenda
    """
    mapa = renderizar_mapa(grafo, agente, caminho)
    
    legenda = [
        "\n=== LEGENDA ===",
        "S = Inicio        G = Objetivo",
        "A = Agente        . = Caminho",
        "$ = Recompensa    * = Coletada", 
        "# = Parede        + = Destaque",
        "",
        "TERRENOS:",
        ". = Solido (1)    ~ = Arenoso (4)",
        "^ = Rochoso (10)  & = Pantano (20)",
        "================="
    ]
    
    return mapa + "\n" + "\n".join(legenda)


def simular_movimento(grafo, agente, caminho, velocidade=1.0, mostrar_stats=True):
    """
    Simula o movimento do agente pelo caminho com anima칞칚o
    
    Args:
        grafo (Graph): Grafo do ambiente
        agente (Agent): Agente a simular
        caminho (list): Lista de n칩s do caminho
        velocidade (float): Velocidade da anima칞칚o (segundos por passo)
        mostrar_stats (bool): Se deve mostrar estat칤sticas
    """
    if not caminho:
        print("Nenhum caminho para simular!")
        return
    
    print(f"\n=== SIMULANDO MOVIMENTO - {len(caminho)} PASSOS ===")
    
    # Reseta agente para posi칞칚o inicial
    agente.resetar_estado()
    
    for i, no in enumerate(caminho):
        limpar_console()
        
        # Atualiza posi칞칚o do agente
        if i > 0:
            no_anterior = caminho[i-1]
            # Encontra custo do movimento
            custo_movimento = 0
            for vizinho, custo in grafo.obter_vizinhos(no_anterior):
                if vizinho == no:
                    custo_movimento = custo
                    break
            agente.mover_para(no, custo_movimento)
        
        # Renderiza estado atual
        print(f"PASSO {i+1}/{len(caminho)}")
        print(renderizar_mapa(grafo, agente, caminho))
        
        if mostrar_stats:
            print(f"\nPosi칞칚o: ({no.x}, {no.y}) - Terreno: {no.tipo_terreno.name}")
            print(f"Custo Acumulado: {agente.custo_acumulado}")
            print(f"Recompensas Coletadas: {len(agente.recompensas_coletadas)}")
            
            if agente.recompensas_coletadas:
                recompensas_pos = [(r.x, r.y) for r in agente.recompensas_coletadas]
                print(f"Posi칞칫es das Recompensas: {recompensas_pos}")
        
        # Pausa para anima칞칚o
        if i < len(caminho) - 1:  # N칚o pausa no 칰ltimo passo
            time.sleep(velocidade)
    
    print(f"\n游꿢 OBJETIVO ALCAN칂ADO!")
    print(f"Custo Final: {agente.custo_acumulado}")
    print(f"Recompensas: {len(agente.recompensas_coletadas)}")


def gerar_ambiente_personalizado(largura=8, altura=6, densidade_terreno=None):
    """
    Gera um ambiente personalizado com par칙metros espec칤ficos
    
    Args:
        largura (int): Largura do grafo
        altura (int): Altura do grafo
        densidade_terreno (dict): Probabilidades dos terrenos
        
    Returns:
        Graph: Grafo gerado
    """
    if densidade_terreno is None:
        densidade_terreno = {
            TipoTerreno.SOLIDO: 0.4,
            TipoTerreno.ARENOSO: 0.3,
            TipoTerreno.ROCHOSO: 0.2,
            TipoTerreno.PANTANO: 0.1
        }
    
    grafo = Graph()
    
    # Gera n칩s com distribui칞칚o personalizada
    for y in range(altura):
        for x in range(largura):
            # Escolhe terreno baseado nas probabilidades
            rand = random.random()
            soma_prob = 0
            tipo_escolhido = TipoTerreno.SOLIDO
            
            for tipo, prob in densidade_terreno.items():
                soma_prob += prob
                if rand <= soma_prob:
                    tipo_escolhido = tipo
                    break
            
            grafo.adicionar_no(x, y, tipo_escolhido)
    
    # Conecta n칩s (4-conectividade)
    for y in range(altura):
        for x in range(largura):
            no_atual = grafo.obter_no(x, y)
            if not no_atual:
                continue
                
            # Conecta com vizinhos adjacentes
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                novo_x, novo_y = x + dx, y + dy
                if 0 <= novo_x < largura and 0 <= novo_y < altura:
                    vizinho = grafo.obter_no(novo_x, novo_y)
                    if vizinho:
                        grafo.conectar_nos(no_atual, vizinho)
    
    return grafo


def distribuir_recompensas_estrategicas(grafo, num_recompensas=5):
    """
    Distribui recompensas de forma estrat칠gica pelo grafo
    
    Args:
        grafo (Graph): Grafo do ambiente
        num_recompensas (int): N칰mero de recompensas a distribuir
        
    Returns:
        list: Lista de n칩s que receberam recompensas
    """
    todos_nos = grafo.obter_todos_nos()
    
    if len(todos_nos) < num_recompensas:
        num_recompensas = len(todos_nos)
    
    # Evita colocar recompensas em terrenos muito caros
    nos_validos = [no for no in todos_nos 
                   if no.tipo_terreno.custo <= TipoTerreno.ROCHOSO.custo]
    
    if len(nos_validos) < num_recompensas:
        nos_validos = todos_nos
    
    # Seleciona n칩s aleat칩rios
    nos_recompensa = random.sample(nos_validos, num_recompensas)
    
    for no in nos_recompensa:
        no.tem_recompensa = True
    
    return nos_recompensa


def validar_ambiente(grafo, no_inicial=None, no_objetivo=None):
    """
    Valida se o ambiente est치 bem formado para busca
    
    Args:
        grafo (Graph): Grafo do ambiente
        no_inicial (No): N칩 inicial (opcional)
        no_objetivo (No): N칩 objetivo (opcional)
        
    Returns:
        tuple: (is_valid, error_messages)
    """
    erros = []
    
    # Verifica se h치 n칩s
    if not grafo.nos:
        erros.append("Grafo n칚o possui n칩s")
    
    # Verifica conectividade
    if not grafo.validar_conectividade():
        erros.append("Grafo n칚o 칠 totalmente conectado")
    
    # Verifica tamanho m칤nimo
    if len(grafo.nos) < 30:
        erros.append(f"Grafo muito pequeno: {len(grafo.nos)} n칩s (m칤n. 30)")
    
    # Verifica n칩s inicial e objetivo
    if no_inicial and no_inicial not in grafo.nos.values():
        erros.append("N칩 inicial n칚o existe no grafo")
    
    if no_objetivo and no_objetivo not in grafo.nos.values():
        erros.append("N칩 objetivo n칚o existe no grafo")
    
    if no_inicial and no_objetivo and no_inicial == no_objetivo:
        erros.append("N칩 inicial e objetivo s칚o o mesmo")
    
    # Verifica recompensas
    recompensas = grafo.obter_nos_com_recompensa()
    if len(recompensas) < 5:
        erros.append(f"Poucas recompensas: {len(recompensas)} (m칤n. 5)")
    
    return len(erros) == 0, erros


def obter_estatisticas_grafo(grafo):
    """
    Calcula estat칤sticas do grafo
    
    Args:
        grafo (Graph): Grafo do ambiente
        
    Returns:
        dict: Estat칤sticas do grafo
    """
    if not grafo.nos:
        return {"erro": "Grafo vazio"}
    
    # Conta tipos de terreno
    contagem_terrenos = {}
    for terreno in TipoTerreno:
        contagem_terrenos[terreno.name] = 0
    
    for no in grafo.nos.values():
        contagem_terrenos[no.tipo_terreno.name] += 1
    
    # Calcula outras m칠tricas
    total_nos = len(grafo.nos)
    recompensas = len(grafo.obter_nos_com_recompensa())
    
    # Calcula custo m칠dio
    custo_total = sum(no.tipo_terreno.custo for no in grafo.nos.values())
    custo_medio = custo_total / total_nos if total_nos > 0 else 0
    
    return {
        "total_nos": total_nos,
        "dimensoes": f"{grafo.largura}x{grafo.altura}",
        "recompensas": recompensas,
        "custo_medio_terreno": custo_medio,
        "distribuicao_terrenos": contagem_terrenos,
        "conectividade": "OK" if grafo.validar_conectividade() else "FALHA"
    }


def escolher_nos_aleatorios(grafo, evitar_recompensas=True):
    """
    Escolhe n칩s inicial e objetivo aleat칩rios no grafo
    
    Args:
        grafo (Graph): Grafo do ambiente
        evitar_recompensas (bool): Se deve evitar n칩s com recompensas
        
    Returns:
        tuple: (no_inicial, no_objetivo)
    """
    todos_nos = grafo.obter_todos_nos()
    
    if evitar_recompensas:
        nos_sem_recompensa = [no for no in todos_nos if not no.tem_recompensa]
        if len(nos_sem_recompensa) >= 2:
            todos_nos = nos_sem_recompensa
    
    if len(todos_nos) < 2:
        return None, None
    
    # Escolhe dois n칩s diferentes
    no_inicial = random.choice(todos_nos)
    nos_restantes = [no for no in todos_nos if no != no_inicial]
    no_objetivo = random.choice(nos_restantes)
    
    return no_inicial, no_objetivo


# Teste b치sico do m칩dulo
if __name__ == "__main__":
    print("Testando m칩dulo utils.py...")
    
    # Gera ambiente de teste
    resultado = gerar_grafo_labirinto_com_biomas()
    if resultado:
        grafo = resultado[0]
    else:
        print("Erro na gera칞칚o do grafo")
        exit(1)
    
    print("=== ESTAT칈STICAS DO GRAFO ===")
    stats = obter_estatisticas_grafo(grafo)
    for chave, valor in stats.items():
        print(f"{chave}: {valor}")
    
    print("\n=== MAPA GERADO ===")
    print(renderizar_mapa_com_legenda(grafo))
    
    # Testa valida칞칚o
    no_inicial, no_objetivo = escolher_nos_aleatorios(grafo)
    valido, erros = validar_ambiente(grafo, no_inicial, no_objetivo)
    
    print(f"\n=== VALIDA칂츾O ===")
    print(f"Ambiente v치lido: {valido}")
    if erros:
        for erro in erros:
            print(f"  - {erro}")
    
    print("\nTeste conclu칤do!")
